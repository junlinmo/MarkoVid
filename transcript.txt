Okay, so I'm having a little trouble with the air play again, which I contacted came about but I'm Tethered to the desk Again by cable. But before we finish up talking about the last of the lecture slides here I have not spent for you that's related to post 281. So you may have heard that after you're done with 281. You have trouble getting enrolled in upper level classes and we know the reason why and it's true advising appointments and through data we found that students who get schedule first are not necessarily nice about scheduling and I've talked to students in advising who tell me things like I got to sign up really early. So I signed up for for upper levels and I'm going to drop two of them later.And I try to be polite to them. I try to encourage them and say things like, you know, if you drop two of those today, you're going to make two other people really really happy. You're going to make their day. You're not even going to know who they are, but they're going to be really happy and I'll do it eventually. So the department noticed this was happening and decide we've got to do something about so we asked the registrar. Is there a way that the registrar can say from this list of classes you can only be enrolled into and they said no we can't do that. We said what if we want to do it ourselves, they said we will fully support your decision in that so the department and got someone in the department to implement the system that goes and scrapes the registration data all the time. And so what's going to happen. Is it for starting in Winter registration is going to come in stages which is always happen, but the stages are going to be a little different now, so at the beginning everybody is going to have a chance to enroll in classes, but within that first stageIf anyone signs up for more than two classes this system within an hour will send them an email that says you're enrolled in more than two classes from this list. If you don't get back down to two classes from that list within 24 hours, we will drop classes randomly until you're down to two so many people there like who I really want this one. I'm going to pick one of those three. Well, you better pick one of those three now because otherwise we'll be might drop the one you want the most so then after everybody is gotten a chance to enroll then people who are declared. Majors will be allowed to get a third-class if they want one the data says only about six to seven percent of students actually keep a third-class most don't but many sign up for three or four because they can and we're going to put it into that. So it's going to make it easier for you coming out of 281 into next semester to get into upper-level classes.Now the date also says about 30% of students only enroll in one upper level. That's because they're doing things like upper-level + 370 upper-level + 376. So if you were planning like while next semester, I'm not going to get an upper-level. I'll just do 3 7376. I would say your chances of just starting next semester. I going to be a lot better to get into at least one upper level and Straight Outta 281. So to do that you need to be to Clarence. So if you haven't done it yet check for CSE or cslsa check if you're qualified to declare and get declared. I would say no later than week 8 because it takes about a week for the paperwork to go through everybody before it's approved and you want that to be done before your enrollment date comes up in like 10 to 11. So if you aren't yet declared I would look into are you qualified to declare and get declared if you're in Ellison a you might have to do the worker.Sandwiches declare something else declare a c s l s a minor which gets you into one upper level. And then and then make sure that you're ready to declare this time next semester. So anyway, so that should make things easier for you for an S7 on 281 news. Sort of the AutoTrader will be ready in another couple days. I'm basically almost done accept submissions can be too big and I'm going to so I'm going to limit like the biggest test case I'm going to make them smaller so that we don't accidentally fill up the hard drive and then project so I want that to happen. So I got a little bit of work to do to make sure that doesn't happen. But then we get the auto greater open project to you basically need for most a project to you can start now the part that you can't do after we do the heaps and heaps art lecture. You need that for part of Part B. So parte you can do it now Part B. The thing that you can't do yet is the binary Heap and hopefully we'll get to that today. So we'll see. Okay, so we're going to finish looking at this last time at the at the function that produces all the different permutations. So try that out and see how it works. Also. Look at theirs the STL has something called Next permutation where if you give it a vector and call next permutation, it'll give you the next permutation on that tractor or tell you that it's not look at what it does. Each of them has some advantages and disadvantages for stl's next permutation to work the values must all be unique and for some things that we might want to do. We might want to have like all permutations including duplicates. Like what is there are duplicates in there. I might want them to occur more times in the fermentation. For example, here's a interview type question suppose. We gave you some digits we gave you some operators you can use any operators. You want of that list plus minus time. Divide you can't use explanation. You can't use concatenation. I give you a target number. Can you make that Target number by using those numbers and those operations? So here's a couple of examples like how to get 22 23 25 Etc. So the how would you do this in code? We could do it in Code by making like every combination of like plus plus plus plus minus minus plus minus divided Federer. We can prove every combination produce every permutation of those digits in operators where a digit must be followed by an operator and see if we can produce that number so we can do this on paper we can do it in code. okay, so now we're going to go on to the next set of slides here, which is What's wrong, which is he? Okay. So with the preparing for project to one thing you should look at is because in part a sew in part A is the mine Escape in part A you must use standard priority queue. So look at how it works how to declare one how to create one that has a funk door to determine priority short little program to do it. Like I've got to I've got a class that puts an integer inside of it and I've got a funk tour to determine order. What if I want biggest first. What if I want smallest first what if I want even numbers have precedence over odd numbers Etc. So also look at the pairing Heap stuff and read there's an SPL resource the professor and found which is a list of resources in the STL. So we got like a list of those things. That'll be useful. So when you start looking at the pairing heat do not leave it till the last minute. The pairing Heap is a good chunk of the points overall and it's going to be where you're going to spend. I would leave like a couple days from the point that I understand parents and it's time to implement it do not say I'm going to do that in 2 hours. No, maybe two days would be better because the parent keep data structure is all held together with pointers and it's really easy to have a dangling pointer at segfault infinite Loops because something points to itself when you followed around forever, there's lots of ways for pairing Heap to go wrong. The meld is the most important part of the parenting. So there's there's a section bus back as long I will admit but that's because we added a bunch of appendices at the end with some helpful tips. So there's a whole section la pendix. See I want to say is all about a bunch of tips for implementing the different priority queues and most of it is about tips for implementing parent hate. So look at that meld is really really important function because once you have meld meld as used by adnode meld is used by pop melda's used by update held and add note is basically push call Dad node node is like push accepted return the pointer rose bushes just void. But so basically pushing a meld top use of meld meld update priorities. You called Everything depends on male meld is not a big function. It's got to be old one which means it can't have any Loops. It's just got to basically have some if statements in some assignments and return. So the Things that you give to meld should themselves effectively be a parent heat which means they don't have any sibling. They don't have a parent or previous. They are the root of a parenting. So if you have two things which are roots of pairing heaps whether it's a whole bunch of monody parent or just one note like when you want to do add know you call Mel do you say hey, here's the whole parent keep I've already got here's one node put them together and that's what it does smell puts two parakeets together and form mailed to be efficient and to be easier right? It's really important that these are true. If each one had self has no sibling no previous or parent. It makes it a lot easier to write. So look at the examples also draw out examples of parent leaves drawing an example. Like here's to parent here to a three or four knows each what is meld have to do Draw it out and it'll make the coat a lot easier to write. Don't try to go from the concept to the code brought some examples and understand how mailed Works before you start coding. Okay. So today we're going to talk about heaps before we talk about keeps we have to go backwards a little bit and talk about trees. And so what is a tree so tree is a graph a graph has nodes or we might call them vertices no vertices connected by edges and if we have a connected graph connected meaning there's no note that I just can't get to from here. So if it's connected and there are no Cycles, it's a tree and equivalent definition. So I have a graph where any two nodes are connected by a unique shortest path that also implies that there are no Cycles. So they're basically equivalent definition. So if we got a tree then we can identify this relationship between anode and the children below it between anode and the parent node above it. And for today we're going to stick to Binary tree's so in a binary tree every node has at most two children. There's no nodes with three or four seven children. So it might have zero children if it's a leaf, it might have one or two children if it's not a lie, so let's start out of definition payload start the bottom what is leave now? So the leaf node is a note that has no children. So that's easy. What about the route the route then is the top most node in the tree. The parent is the predecessor the level above a given node a child is the note below and given know that have that relationship between parent and child and ancestor could be a parent of a parent to parent of excetera. So anything closer to the route along a connected path, so here like if I look at this for zero is not an ancestor of 4 because it's not in a path going towards the root. The fours ancestors would be 76 and 2 if we look at descendants descendants is a child of a child etcetera going down away from the root Sol in this everything is a descendant of 2. Now we haven't made any rules yet about where to put thanks for just saying. Hey, we got a tree a tree has it's going to be a binary tree nodes have at most two children, but we haven't made any rules about where values go yet will get to that. When we want to represent a binary tree one way to do it would be to have a pointer Bay structure so I can have a node structure nodes Point by left and right child. They could be if I don't have a left or a right child those could be no pointers and I've got a data item and now we could if we weren't doing binary tree's we could add like three child pointers for child point we could add a vac of vector or. Gov child pointers to say. Hey, there's no didn't have as many children as you wanted to have. But for today, we're not going to do that where to stick to Binary tree's now if we have this we've got an efficient way to move down when I got an efficient way to go from parents child without a pointer going up. I don't have an easy way to go up the tree if I give you a pointer like in this one if I give you a point or two for you have no way to easily to find for his parents. So that would take more data more more pointers that we have a pointer pointing up for it if we want to do that. Now if I give you a pointer to a note like if I give you a pointer to 6, I have effectively given you a sub tree of the original tree. So if I give you a pointer to a node that node and all of its descendants are some tree, so if I give you a pointer to six week, we would not say that the that this is a sub tree that's not a sub tree because if I gave you a pointer to 6, you can get all the way down to four and three so if if we look at a sub tree, it's some node and all of its ancestors are proper subtree. SO2 is a sub tree. It's a sub tree that happens to be the whole tree. Now some properties. So for these now these are going to seem like a little bit of an odd number in system, but it's going to be important later on we want to be consistent for the start here. So first off the size of an empty tree is here out. So if I give you basically a null pointer I say what's the size that treat you say zero because there's no no it's okay. So then if I give you a pointer to anything no pointer the size of that tree is the size of its left child plus besides that's right child plus one for the note itself. So like if I gave you a pointer to G. The size of the tree g is left is zero right is 0 plus 1 for GSL the size of the tree pointed to buy Gia's size one if I gave you a pointer to a the size of a while we out of all the notes 1 2 3 4 5 6 7 8 9. So if I gave you appointed a the size of that tree is 9 its left + right sides plus one for the a then we do that recursively all the way through. Alright, so that's the size of a tree what about the height of a known? So if we want to know the height of a node the height of the note is the maximum of its left child and write child's height notice where the parentheses are. So we take the maximum height of its children and we add one. So for example, what is the height of G? Well, the height of its left some tree is 0 in height of its rights of tree is zero the max of 0 1 0 0 the height of G is one so the height of you if we write Heights in here is one age is one. In fact, all the leaves are I want so that makes it easy anybody is it to leave your height want? Alright, what about the height of d? So how you DS2 we take one and one Dee's children are both one one and one Max has one add one Saudi is a height of 2. What about sea? To run the easy ones here, but it's so she's excited to what about be? What's the height of be? So look at its children children are height. Fun wake up people two in one. So we got the heights of the heights of bees children are two and one maximum is too high to be that is 3. Okay. Send the height of a Take the heights of children take the maximum add one is at height of 4. So that's her definition of height. The definition of height is basically saying how far are you from having? No pointers below you what's the longest path between you and no pointer looking downward? So death is the opposite. It's basically saying how far away from are you from having? No parent. So if I give you an empty Tree by give you a no point it's depth is zero. Otherwise, it's the death of its parent plus one. Now, if we don't have parent pointers, that's just a little harder. So let's just pretend to be able to do this the nice thing about the doubt. So that was the height was in that color eyes change colors over here. So if we look at the death D the death D is nice and consistent a is that add up the one being Ciara death of to d e Enough are all at height of a depth of 3 H&G or at a depth of 4. So it's basically their distance from the root pointer not their distance from the node their distance from the root pointer. So the root pointer is up above a basically is at a height or depth of zero everything below. It is at increasing depth every time we go down bio link. So those are definitions of height and depth now, those aren't going to be super important just yet. They're going to be really important when we do binary tree's after the break and especially self violent bounce in binary tree's are definition of height is going to be really important there. So today it's going to be a little important not here for this height and depth and size. So now we're going to add a property we're going to say that when we represent the binary treats for today's purposes. We want it to be a complete binary tree. So the complete rule this is where height comes in. So the complete rule basically says every death except possibly the last must be filled and your fault if a death is not filled the nodes that do exist must be filled from left to right. So in the one that says complete basically this level is full. There's no other nodes that can be in there. This level is full. This depth is full and this depth is field from left to right. So at a given depth of the tree must either before if it's not the last level it must be fall. The last level doesn't have to be full but it does have to be filled from left to right. So then the middle one says it's not complete. What's the problem with the middle one? It's yeah, it's whose whose child see. Yeah, so she is missing. There's a gap here if we fill that Gap in it would go back to being complete. Now. The last one it says last one over there is not complete. Why not? Yeah, see there's a whole here. Supposed to have a right child there if he had a right child, then it would be complete again, but we don't want basically we don't want any gaps in our if there's a gap it's not complete. Yes. The level so when we say level basic I should just change this side instead of saying level. I should just say deaths here. So high tide is high does a function of who's below me but death is a function of where am I from the top and everybody's at the same distance from a given level is the same distance from the roof so high it varies by the structure of the tree death to just increases as we go down. Yes. For the one that's complete. We just get rid of all my markings here. Whoops. Okay, so if she wasn't there that would still be complete because the last level I filled it from left to right while left right was OneNote at the left. So if I get rid of G, it's complete if I leave G there and I get rid of age that it's not complete because I'm not feel left right if I get rid of G and H is it complete? Yeah, because now this is the last level and it's filled from left, right? Okay. Someone over here had a question. Okay, I guess we got an answer already. Okay, so that's our complete property. The reason that we want that complete property is what if I wanted to take a binary tree and I didn't want to use up all that memory for pointers to Children. What if I would just wanted to put it into a vector? If I allowed there to be gaps, I don't have very good control over the size of the vector. So if I allow there to be gaps anywhere, I can have a stick that goes like this. Then how big does my Vector need to be to store that big stick of of nose? Like two to the end, right? It's got to be really really big factor and that's not efficient. That's almost all wasted space. So if we if we force the complete property to hold then we can store a binary tree in a vector of exactly the same size as the tree now, maybe I could have a vector you know this because it grew a little bit, you know, the vector has some a few on use faces, but the unused faces are at the end of the actor that is where they should be. So does this allows us to fit things into the array very efficiently rare Vector. Now one thing that we have here they have to be careful of is were using one based indexing. We did this partly because of this is what it is in clrs. Now when we go to implement this which oh, by the way, you have to do this for project to you're going to have to change when you go to implement the binary stop priority queue from the slides. You've got to change from one based indexing in the slides to using a date of actor behind the scenes that start at zero. So the Project's back has near the end. It's got a whole section of tips on implementing the different pirate accused. There's a section about binary PQ. It gives you three basic choices, which are Figure out modify all the code to do zero based indexing internally. That's a great solution. But it's the hardest second solution is have a date of actor of size and plus one with a dummy element that index Sierra. That's easy if you get the syntax, right, but it waste a little bit of space. The simplest solution is we gave you some code for I get out of it function so that when the code that we're going to see you in a few minutes when the code says like keep subbed. Hey what you would do as you would write get element. Get element of K and we got a concert reference number function that will go get it for you. So that's the easiest way to do it. Just remember one thing never ever ever copy and paste code from a PDF into your compiler because it has hidden invisible spacing characters make the font look pretty it's got a minus sign that's not a real minus sign. It's like an extra with mine is fine, but it looks like a minus sign but doesn't compile. So retype whenever you got something in the project spec retype it if you wanted in Kotor or an ending in an input file as we gave you is in the tax files, but the most like six lines of code, you have to retype so if we've got a complete binary tree that we stored into an array or vector if I give you an index, like I said, hey, I've got to know that index. I take a few minutes to talk to your neighbors figure out where is eyes parent where is eyes left and right tile don't even more important than where I left right child is does I even have children is I at least known or not because if I leave node, we shouldn't even be worrying about where it's children are. Okay. So take a few minutes to answer those questions. Assuming assuming like I said if I give you an index eye where is eyes parent? At I I over to so I divided by 2. Do I have to worry about like ceiling of that floor of that? No, because it's a division integer division in C. Plus plus I'll take care of it for us. That's easy. Okay, so if I know where I is what about where is its left child? that be okay. So two times I is where's my left child? Where's my right child is going to be two times. I plus one. Okay, then what if I want to know it does I represent the leaf note. Can I do that just with I and no other information? now, what do I need the yeah, I need the size so it so it's written down here. So to know if I is a leaf node or not. I need to know the size. So one thing I can say is I can say if I is greater than size over to that. It is a leaf note. So if that's true, it's a leaf node, or I can say if it's so that's one way of saying just changed its rewrite that. So if I want to know is it a leaf node, if it's a leaf node, it has to be I has to be greater than size / 2 if I want to know is it an internal node if it's an internal node, I have to be less than or equal to size over to. Or alternatively I could say. I * 2 is less than or equal to size. So both of those definitions work for the is it a is it an internal node with the division? We've got to be careful because of the actually not what would we want to do multiplication there because integer division might save us. So let's not do that. I know that works. If we do the multiplication we might get a we might get a roundoff error on some cases. So I know that works because of integer division. Okay, so that gives us those values and and decision. What's not so now what we'd like to do is we'd like to add a property of where to put things. So normally you're used to taking a binary tree and imposing a rule for binary search. So the binary search rule is small nodes. Go to my left big nose go to my right. We're not going to have that rule. We're going to a different room. We're going to add a rule that says that you're Children must have a priority that is not bigger than yours. The nodes your parent must have a priority that is not less than yours. So what does priority mean what priority can mean different things to different people? So we've got two different trees here. One of them. The last one says basically close to the beginning of the alphabet is high priority. Not remember behind the scenes if we were if these were actually put single quotes around them if these were all letters remember letters all have an ASCII value It's like capital A is 65 capital B is 66 this one on the left is saying small values are high priority. That's called a meme keep. The one on the right is saying that highest values have highest priority that's called a Max Heap. So it's always high priority is at the top of the heat. But what is the highest priority depends on our definition? Is it a Min Heap or a maxi? But always the highest priority is at the root because the notes below me cannot have a higher priority than me and that holds true throughout the tree. So that's what we call the Sheep ordering or heat property. So the heat property is my priority is never less than my children or my children never have a higher priority than me. They could have the same price. I can have a tree with like five five and five where my children have the same priority as me, but they can't have a higher priority than me. So if we take those two properties the completeness properly that lets us put it in the ray efficiently and we add the keep ordering property. Then we're going to use those two properties together to make an efficient way to do priority queues and an efficient way to do sorting. So this this these two properties and give us two different things that we can do with them. So for example here, we've got a maxi for the biggest priority is highest value. We've got shown in the tree representation and the array representation when were trying to do operations like is this thing does the heat property hold in this tree or not? It's a lot easier to see that in the tree than in the array but behind the scenes we're going to code this with an array or actually a vector to hold our data and then that's where we get into the problem of 0 vs. 1 based indexing. So big idea. So a Max Heap is when the highest value is the most extreme Min Heap lowest value is the most extreme we make that decision based on our needs like what what is high priority to me? What is low priority to me? So then after I made that decision, I just make a funk door that makes my priority queue keep them in the right order then using these hips we can build A priority queue or we can build Heap Sort and we are going to go with the array implementation of it. So we've seen wow the Trees in the arrays can be made equivalent is if we impose the completeness property. We're going to implement them always with Arrays or better yet vectors. We're not going to implement them with pointers a nice thing about that is we use last memory. We don't have all that memory of all those points are set aside. We've got an efficient way to go down to a child is too high and too high plus one. We've got an efficient way to go upward I / 2 and we don't have any memory set aside for pointers. So before we get to the really cool things we got to have some tools. Yes. Correct. So Maxi Borman here. So when were talking when we just say the word priority so my children never have a higher priority than me, but the ordering of biggest child smallest child doesn't matter left to right. So we never worry about laughter right here. We always worried about child versus parents. Okay, now like I said to say before we can get to the really cool stuff. We need some tools to use to make a really cool stuff happened. So suppose that you are a binary and you don't have data you have pointers today. I'm holding on to the data and behind the scenes in the back tire of my data. I change the to 2:35. And then I tell you hey priority binary keep the value at index 8 just increased fix yourself. So how do we do that? So that's what this showing down at the bottom of the data at index 8 change from 2 to 35. So appear this to changed into a 35. Now. The first thing we have to ask is is it still a heat or not? Because if that too had changed two or three it would still be he fluent have any after work to do but since the to change to a 35 in either case, we've got to check versus its parent at least we got to check this thing that change versus his parents to see is it in the new value bigger than the parent. So here 35 is bigger than the parent value of 9. So what do we do to get this back to being Heap? Really simple. So 35 moves up and nine moves down. So is the keep property restored? No, because 35 still is bigger than his parents. So we stopped again. So 35 moves up again. 9 move down and then we check again is 35 higher part. I contain bigger, but we really should say higher party is 35 higher priority than its parent know. Therefore. We restored the heat. We've gotten the heat property back so over on the right we had the array representation while in the array representation the to change to a 35 then the 35 swap with the 9 so 35 moved up here and 9 move down then 35 swap with 18. So 35 moved here 18 move there. So the array implementation is kind of hard to work with it's easier to work with the tree representation and just understand behind the scenes because it's a complete binary tree behind the scenes. It fits really well in the back door. But in the tree representation when we're done, we've got 81 the whole right hand side wasn't involved in this 14015. Change 7 and 4 didn't get involved. We got a 35 here a 18 if I crossed out in 18, so I've got 18 here and A9 down there. Okay, so that's if I had a value increasing priority. So it says bottom up fix a bitter a better Title Here would just be fixed up. We fix upward because of value increased in priority. We fix upward in the tree. Yes. No, so we don't care about left vs. Right? All we care about is child versus parent If the child is a higher pressure than parent they've got to be swapped but is the left child higher pressure than the right. I have no cares about that at all. And that makes it easy though. I've got less data to check. And everything that we need to do will still be efficient no matter whether the biggest Ally was in the right or left child. Yes. CSO priority is always descending from top to bottom is highest priority as highest value. It's a maxi if lowest value is highest priority. It's a mini. But yeah, the highest priority should always be at the root the things below the root should be either the same or lower priority than the root and that holds everywhere. Okay, any other classes yet? Because 18 is at a is below a 35 the heat property is all that's important not where I am relative to think of this. It's important to not be if it's a weird new English thing, but it's important to not be greater than your parents now. Usually at least in most countries you want to do better than your parents always it's always striving forward. You don't even if your parents are great your parents want to see you do better than they did so here but in a priority queue though, you can't be a higher priority than your parents, but I don't care about my aunt or Uncle over there on the side. So it we only care about the values in a lineup word that are linked together. So node can't be a higher priority than its parent but other things to the left or right of it above and to the left above and to the right don't matter. Okay, so let's look at the code for fix up. So for fix up this is saying and noticed in the in the title here. It's a little bit separated the priority has increased. So if the priority of the value has increased we must do a fix-up. So let's look at the code. It says you give me an array of that data and integer K now when we look at implementing this this should be a member function. The Sheep should be a member variable and then we don't need it as a parameter or only friend, but it would be the index that we have to fix so that makes things a little bit easier cut down on the framers. So we got the data that we have to let those stored in the array of actor and we've got the integer k k is the index. that changed so line to says while K is greater than 1 and something else. So let's work out then K is greater than 1 so while K is greater than 1 what does that mean while what is true? Yeah, not quite. Think about what we're going to use K as an index. So while K is not just the highest priority. Where is the highest priority? It's at the route. So we're saying while we're not at the route. So while I'm not at the root and I check keep sub-pay over too. Well, if I am K who is in that case over to is my parent. So while I'm not at the root and my parent has a lower priority than me is what line 2 is saying so while I'm not at the root and my parent has a higher priority than me. I've got to keep going. What do I have to do? I swap meet with my parents and I move up a level. Now, let's look at line to a little more closely noticed that what if what if K was want if K is one we've got while taking greater than 1 is false false and anything is false Boolean short-circuiting makes things safe here. Because if we had real one based indexing 1/2 0 and heap of k / 2 would be an invalid index. So the Boolean short-circuiting prevents us from from evaluating invalid Expressions. That's really important in how the code is written. It's even more important in the fix down which were going to do in a minute. Okay, so while I'm not at the root and my parent has a lower priority than me then swap meet with my parent and move up a level to my parents. So they divide equals to remember is the same as k equals k / 2 just a short way of writing it so K moves to the level of parent and then we go back through the loop. If the wild condition is false. It means we either we got to the top or we restored the heat property before we got to the top either way when we're done with this chicks up the heat property has been restored. Yes. in the context of Max Yes, so if we're doing a Min Heap, we would have to change that less than 2 and greater than and then in when you implement this more even more important when you implement this you are not going to do last night and you're not going to Greater that there is going to be in the base class. So we gave you classes that are in a inheritance relationship in the Base Class. There's a comparator you will ask the comparator you will ask this compare of a, b where A and B are two things and it will tell you true if the priority of videos watched on the priority of be so it'll take care of the decisions for you. So when you implement this you should never have less than or greater than or anything with respect to data with respect to Hennessey's. Yes, you should be using less than greater than it's ever but with respect to data when you write the code for this you must ask of this - greater than compare. Is the priority of a less than the priority of B and it'll make the decision for you. So, yes you a question. No, we noticed remember KS is where I am. So when I am the root, there's nowhere else further up to go. But if I am just below the root if I am say index three my parent is that index one. I will check me vs my parent. I will check me versus the route, but when we get to like if I move all the way up, like I swapped myself with root and then I move up to the route. I'm done cuz there's nowhere to go about that. Yes. Cheapest item that says item Heap square bracket. So here is basically an array of items is always either of tree on we're going to do it as an array. This code only works as an array because we're doing operator square brackets and trees don't have operate square brackets. No, no, it just happens to share the same name, which is it violates the principle of orthogonal D, which is different things should be named differently, but we're sort of stuck with it historically so someone can someone created this data structure and they called it a heat because things go with the biggest things go to the top of the heat is the funny description, but it's a little confusing with respect to the cheap where things get nude from. They aren't related at all. Okay, I have another question. Okay. So this is fix up. So we swapped until things are back to where they should be. Now a good question is what is the complexity of fix up what let's not look at the code. Let's look at the algorithm and assume that the codes of implementation that should be the same complexity. So how many levels do I have to fix up at most? Might be all right. So how many levels is there are endnotes in this binary Heap how many levels are there? Yeah, well login and why couldn't there be any of them? Why what about a big stick of them? Remember we imposed? Completeness because we imposed completeness. We can't have a big stick. We've got to have full level full level full level Etc level. That's still 2 left, right? We're only going to have at most one level that's not full which means the height of the tree the overall height the maximum height of this tree is equal to basically log of an approximately equal to well. How about sealing a Blog event would be a little bit closer. So if I've got like here, I've got 9 nodes log of log base 2 of 9 is 3 but we've got a height of 4 something so feeling about this more so it's about login is the height of the tree and since we never go sideways since I only go up up up the biggest number of levels. I can ever go through his login. We could get lucky the two could have changed to a 3 compared to its parent. Nopi property still good we're done so it couldn't be all of one at the best case. You didn't become bigger than your parent but it could be as bad as well again. So that's pretty good. We got a login fix up. Well, what about if a value decreases in priority, so if a value decreases in priority so that 18 changes to 3. Now we have to check. Are you smaller? Are you lower-priority better? Say, are you lower priority than your children? Yep. So which child should we swap with? In general which loud should we swap with? Yeah, the highest priority if I were to stop so remember, this is big values big Prairie. If I were to swap the three with the seven, we still would have a broken hip because seven would be a lower priority than 9 so it's important. We always want to swap when we're fixing down top-down fix to say fix down. When were fixing down we always swap with the highest priority child. Not the left not the right just the highest priority. So we swapped with our highest priority child 9 and 7. We pick 9, so 9 moves up and three moves down. Okay, we compare 3 to our children. Now, it's higher priority than one child, but lower than the other that doesn't matter just pick the highest priority child is the three lower priority than the highest priority child. Yes, it is. So we swap the three with the for SO3 move down 4 moves up in the array implementation 18 change to 3 which then swap with. The child of that one which was 9 so 3 went there 9 went over here then 3 swap with its largest child, which is for SO3 moved over here and form over there when we're all done. We got 81 right hand subtree didn't change for this example 157 stayed the same and then we've got nine and four two and three. Okay, so that was our fix down example. So what's the complexity of fixed on him before we look at the code? Should be about the same will never have to fix more levels than exist because we always go down down down. We never go sideways if I go sideways and worry about like my order relative to my siblings. Then we've got too much work to do. We we just want to go down to the branch of highest priority children. In login time will reach the bottom. Okay, so this is fix down so it